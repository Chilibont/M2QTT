#region Assembly M2Mqtt.Net, Version=4.3.0.0, Culture=neutral, PublicKeyToken=null
// C:\Users\Utente\source\repos\Chat\MQTT\packages\M2Mqtt.4.3.0.0\lib\net45\M2Mqtt.Net.dll
// Decompiled with ICSharpCode.Decompiler 7.1.0.6543
#endregion

using System;
using System.Collections;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using uPLibrary.Networking.M2Mqtt.Exceptions;
using uPLibrary.Networking.M2Mqtt.Internal;
using uPLibrary.Networking.M2Mqtt.Messages;
using uPLibrary.Networking.M2Mqtt.Session;
using uPLibrary.Networking.M2Mqtt.Utility;

namespace uPLibrary.Networking.M2Mqtt
{
    public class MqttClient
    {
        public delegate void MqttMsgPublishEventHandler(object sender, MqttMsgPublishEventArgs e);

        public delegate void MqttMsgPublishedEventHandler(object sender, MqttMsgPublishedEventArgs e);

        public delegate void MqttMsgSubscribedEventHandler(object sender, MqttMsgSubscribedEventArgs e);

        public delegate void MqttMsgUnsubscribedEventHandler(object sender, MqttMsgUnsubscribedEventArgs e);

        public delegate void ConnectionClosedEventHandler(object sender, EventArgs e);

        internal class MqttMsgContextFinder
        {
            internal ushort MessageId { get; set; }

            internal MqttMsgFlow Flow { get; set; }

            internal MqttMsgContextFinder(ushort messageId, MqttMsgFlow flow)
            {
                MessageId = messageId;
                Flow = flow;
            }

            internal bool Find(object item)
            {
                MqttMsgContext mqttMsgContext = (MqttMsgContext)item;
                if (mqttMsgContext.Message.Type == 3 && mqttMsgContext.Message.MessageId == MessageId)
                {
                    return mqttMsgContext.Flow == Flow;
                }

                return false;
            }
        }

        private string brokerHostName;

        private int brokerPort;

        private bool isRunning;

        private AutoResetEvent receiveEventWaitHandle;

        private AutoResetEvent inflightWaitHandle;

        private AutoResetEvent syncEndReceiving;

        private MqttMsgBase msgReceived;

        private Exception exReceiving;

        private int keepAlivePeriod;

        private AutoResetEvent keepAliveEvent;

        private AutoResetEvent keepAliveEventEnd;

        private int lastCommTime;

        private IMqttNetworkChannel channel;

        private Queue inflightQueue;

        private Queue internalQueue;

        private Queue eventQueue;

        private MqttClientSession session;

        private MqttSettings settings;

        private ushort messageIdCounter;

        private bool isConnectionClosing;

        public bool IsConnected { get; private set; }

        public string ClientId { get; private set; }

        public bool CleanSession { get; private set; }

        public bool WillFlag { get; private set; }

        public byte WillQosLevel { get; private set; }

        public string WillTopic { get; private set; }

        public string WillMessage { get; private set; }

        public MqttProtocolVersion ProtocolVersion { get; set; }

        public MqttSettings Settings => settings;

        public event MqttMsgPublishEventHandler MqttMsgPublishReceived;

        public event MqttMsgPublishedEventHandler MqttMsgPublished;

        public event MqttMsgSubscribedEventHandler MqttMsgSubscribed;

        public event MqttMsgUnsubscribedEventHandler MqttMsgUnsubscribed;

        public event ConnectionClosedEventHandler ConnectionClosed;

        [Obsolete("Use this ctor MqttClient(string brokerHostName) insted")]
        public MqttClient(IPAddress brokerIpAddress)
            : this(brokerIpAddress, 1883, secure: false, null, null, MqttSslProtocols.None)
        {
        }

        [Obsolete("Use this ctor MqttClient(string brokerHostName, int brokerPort, bool secure, X509Certificate caCert) insted")]
        public MqttClient(IPAddress brokerIpAddress, int brokerPort, bool secure, X509Certificate caCert, X509Certificate clientCert, MqttSslProtocols sslProtocol)
        {
            Init(brokerIpAddress.ToString(), brokerPort, secure, caCert, clientCert, sslProtocol, null, null);
        }

        public MqttClient(string brokerHostName)
            : this(brokerHostName, 1883, secure: false, null, null, MqttSslProtocols.None)
        {
        }

        public MqttClient(string brokerHostName, int brokerPort, bool secure, X509Certificate caCert, X509Certificate clientCert, MqttSslProtocols sslProtocol)
        {
            Init(brokerHostName, brokerPort, secure, caCert, clientCert, sslProtocol, null, null);
        }

        public MqttClient(string brokerHostName, int brokerPort, bool secure, X509Certificate caCert, X509Certificate clientCert, MqttSslProtocols sslProtocol, RemoteCertificateValidationCallback userCertificateValidationCallback)
            : this(brokerHostName, brokerPort, secure, caCert, clientCert, sslProtocol, userCertificateValidationCallback, null)
        {
        }

        public MqttClient(string brokerHostName, int brokerPort, bool secure, MqttSslProtocols sslProtocol, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
            : this(brokerHostName, brokerPort, secure, null, null, sslProtocol, userCertificateValidationCallback, userCertificateSelectionCallback)
        {
        }

        public MqttClient(string brokerHostName, int brokerPort, bool secure, X509Certificate caCert, X509Certificate clientCert, MqttSslProtocols sslProtocol, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
        {
            Init(brokerHostName, brokerPort, secure, caCert, clientCert, sslProtocol, userCertificateValidationCallback, userCertificateSelectionCallback);
        }

        private void Init(string brokerHostName, int brokerPort, bool secure, X509Certificate caCert, X509Certificate clientCert, MqttSslProtocols sslProtocol, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
        {
            ProtocolVersion = MqttProtocolVersion.Version_3_1_1;
            this.brokerHostName = brokerHostName;
            this.brokerPort = brokerPort;
            settings = MqttSettings.Instance;
            if (!secure)
            {
                settings.Port = this.brokerPort;
            }
            else
            {
                settings.SslPort = this.brokerPort;
            }

            syncEndReceiving = new AutoResetEvent(initialState: false);
            keepAliveEvent = new AutoResetEvent(initialState: false);
            inflightWaitHandle = new AutoResetEvent(initialState: false);
            inflightQueue = new Queue();
            receiveEventWaitHandle = new AutoResetEvent(initialState: false);
            eventQueue = new Queue();
            internalQueue = new Queue();
            session = null;
            channel = new MqttNetworkChannel(this.brokerHostName, this.brokerPort, secure, caCert, clientCert, sslProtocol, userCertificateValidationCallback, userCertificateSelectionCallback);
        }

        public byte Connect(string clientId)
        {
            return Connect(clientId, null, null, willRetain: false, 0, willFlag: false, null, null, cleanSession: true, 60);
        }

        public byte Connect(string clientId, string username, string password)
        {
            return Connect(clientId, username, password, willRetain: false, 0, willFlag: false, null, null, cleanSession: true, 60);
        }

        public byte Connect(string clientId, string username, string password, bool cleanSession, ushort keepAlivePeriod)
        {
            return Connect(clientId, username, password, willRetain: false, 0, willFlag: false, null, null, cleanSession, keepAlivePeriod);
        }

        public byte Connect(string clientId, string username, string password, bool willRetain, byte willQosLevel, bool willFlag, string willTopic, string willMessage, bool cleanSession, ushort keepAlivePeriod)
        {
            MqttMsgConnect msg = new MqttMsgConnect(clientId, username, password, willRetain, willQosLevel, willFlag, willTopic, willMessage, cleanSession, keepAlivePeriod, (byte)ProtocolVersion);
            try
            {
                channel.Connect();
            }
            catch (Exception innerException)
            {
                throw new MqttConnectionException("Exception connecting to the broker", innerException);
            }

            lastCommTime = 0;
            isRunning = true;
            isConnectionClosing = false;
            Fx.StartThread(ReceiveThread);
            MqttMsgConnack mqttMsgConnack = (MqttMsgConnack)SendReceive(msg);
            if (mqttMsgConnack.ReturnCode == 0)
            {
                ClientId = clientId;
                CleanSession = cleanSession;
                WillFlag = willFlag;
                WillTopic = willTopic;
                WillMessage = willMessage;
                WillQosLevel = willQosLevel;
                this.keepAlivePeriod = keepAlivePeriod * 1000;
                RestoreSession();
                if (this.keepAlivePeriod != 0)
                {
                    Fx.StartThread(KeepAliveThread);
                }

                Fx.StartThread(DispatchEventThread);
                Fx.StartThread(ProcessInflightThread);
                IsConnected = true;
            }

            return mqttMsgConnack.ReturnCode;
        }

        public void Disconnect()
        {
            MqttMsgDisconnect msg = new MqttMsgDisconnect();
            Send(msg);
            OnConnectionClosing();
        }

        private void Close()
        {
            isRunning = false;
            if (receiveEventWaitHandle != null)
            {
                receiveEventWaitHandle.Set();
            }

            if (inflightWaitHandle != null)
            {
                inflightWaitHandle.Set();
            }

            keepAliveEvent.Set();
            if (keepAliveEventEnd != null)
            {
                keepAliveEventEnd.WaitOne();
            }

            inflightQueue.Clear();
            internalQueue.Clear();
            eventQueue.Clear();
            channel.Close();
            IsConnected = false;
        }

        private MqttMsgPingResp Ping()
        {
            MqttMsgPingReq msg = new MqttMsgPingReq();
            try
            {
                return (MqttMsgPingResp)SendReceive(msg, keepAlivePeriod);
            }
            catch (Exception ex)
            {
                Trace.WriteLine(TraceLevel.Error, "Exception occurred: {0}", ex.ToString());
                OnConnectionClosing();
                return null;
            }
        }

        public ushort Subscribe(string[] topics, byte[] qosLevels)
        {
            MqttMsgSubscribe mqttMsgSubscribe = new MqttMsgSubscribe(topics, qosLevels);
            mqttMsgSubscribe.MessageId = GetMessageId();
            EnqueueInflight(mqttMsgSubscribe, MqttMsgFlow.ToPublish);
            return mqttMsgSubscribe.MessageId;
        }

        public ushort Unsubscribe(string[] topics)
        {
            MqttMsgUnsubscribe mqttMsgUnsubscribe = new MqttMsgUnsubscribe(topics);
            mqttMsgUnsubscribe.MessageId = GetMessageId();
            EnqueueInflight(mqttMsgUnsubscribe, MqttMsgFlow.ToPublish);
            return mqttMsgUnsubscribe.MessageId;
        }

        public ushort Publish(string topic, byte[] message)
        {
            return Publish(topic, message, 0, retain: false);
        }

        public ushort Publish(string topic, byte[] message, byte qosLevel, bool retain)
        {
            MqttMsgPublish mqttMsgPublish = new MqttMsgPublish(topic, message, dupFlag: false, qosLevel, retain);
            mqttMsgPublish.MessageId = GetMessageId();
            if (EnqueueInflight(mqttMsgPublish, MqttMsgFlow.ToPublish))
            {
                return mqttMsgPublish.MessageId;
            }

            throw new MqttClientException(MqttClientErrorCode.InflightQueueFull);
        }

        private void OnInternalEvent(InternalEvent internalEvent)
        {
            lock (eventQueue)
            {
                eventQueue.Enqueue(internalEvent);
            }

            receiveEventWaitHandle.Set();
        }

        private void OnConnectionClosing()
        {
            if (!isConnectionClosing)
            {
                isConnectionClosing = true;
                receiveEventWaitHandle.Set();
            }
        }

        private void OnMqttMsgPublishReceived(MqttMsgPublish publish)
        {
            if (this.MqttMsgPublishReceived != null)
            {
                this.MqttMsgPublishReceived(this, new MqttMsgPublishEventArgs(publish.Topic, publish.Message, publish.DupFlag, publish.QosLevel, publish.Retain));
            }
        }

        private void OnMqttMsgPublished(ushort messageId, bool isPublished)
        {
            if (this.MqttMsgPublished != null)
            {
                this.MqttMsgPublished(this, new MqttMsgPublishedEventArgs(messageId, isPublished));
            }
        }

        private void OnMqttMsgSubscribed(MqttMsgSuback suback)
        {
            if (this.MqttMsgSubscribed != null)
            {
                this.MqttMsgSubscribed(this, new MqttMsgSubscribedEventArgs(suback.MessageId, suback.GrantedQoSLevels));
            }
        }

        private void OnMqttMsgUnsubscribed(ushort messageId)
        {
            if (this.MqttMsgUnsubscribed != null)
            {
                this.MqttMsgUnsubscribed(this, new MqttMsgUnsubscribedEventArgs(messageId));
            }
        }

        private void OnConnectionClosed()
        {
            if (this.ConnectionClosed != null)
            {
                this.ConnectionClosed(this, EventArgs.Empty);
            }
        }

        private void Send(byte[] msgBytes)
        {
            try
            {
                channel.Send(msgBytes);
                lastCommTime = Environment.TickCount;
            }
            catch (Exception ex)
            {
                Trace.WriteLine(TraceLevel.Error, "Exception occurred: {0}", ex.ToString());
                throw new MqttCommunicationException(ex);
            }
        }

        private void Send(MqttMsgBase msg)
        {
            Trace.WriteLine(TraceLevel.Frame, "SEND {0}", msg);
            Send(msg.GetBytes((byte)ProtocolVersion));
        }

        private MqttMsgBase SendReceive(byte[] msgBytes)
        {
            return SendReceive(msgBytes, 30000);
        }

        private MqttMsgBase SendReceive(byte[] msgBytes, int timeout)
        {
            syncEndReceiving.Reset();
            try
            {
                channel.Send(msgBytes);
                lastCommTime = Environment.TickCount;
            }
            catch (Exception ex)
            {
                if (typeof(SocketException) == ex.GetType() && ((SocketException)ex).SocketErrorCode == SocketError.ConnectionReset)
                {
                    IsConnected = false;
                }

                Trace.WriteLine(TraceLevel.Error, "Exception occurred: {0}", ex.ToString());
                throw new MqttCommunicationException(ex);
            }

            if (syncEndReceiving.WaitOne(timeout))
            {
                if (exReceiving == null)
                {
                    return msgReceived;
                }

                throw exReceiving;
            }

            throw new MqttCommunicationException();
        }

        private MqttMsgBase SendReceive(MqttMsgBase msg)
        {
            return SendReceive(msg, 30000);
        }

        private MqttMsgBase SendReceive(MqttMsgBase msg, int timeout)
        {
            Trace.WriteLine(TraceLevel.Frame, "SEND {0}", msg);
            return SendReceive(msg.GetBytes((byte)ProtocolVersion), timeout);
        }

        private bool EnqueueInflight(MqttMsgBase msg, MqttMsgFlow flow)
        {
            bool flag = true;
            if (msg.Type == 3 && msg.QosLevel == 2)
            {
                lock (inflightQueue)
                {
                    MqttMsgContextFinder @object = new MqttMsgContextFinder(msg.MessageId, MqttMsgFlow.ToAcknowledge);
                    MqttMsgContext mqttMsgContext = (MqttMsgContext)inflightQueue.Get(@object.Find);
                    if (mqttMsgContext != null)
                    {
                        mqttMsgContext.State = MqttMsgState.QueuedQos2;
                        mqttMsgContext.Flow = MqttMsgFlow.ToAcknowledge;
                        flag = false;
                    }
                }
            }

            if (flag)
            {
                MqttMsgState state = MqttMsgState.QueuedQos0;
                switch (msg.QosLevel)
                {
                    case 0:
                        state = MqttMsgState.QueuedQos0;
                        break;
                    case 1:
                        state = MqttMsgState.QueuedQos1;
                        break;
                    case 2:
                        state = MqttMsgState.QueuedQos2;
                        break;
                }

                if (msg.Type == 8)
                {
                    state = MqttMsgState.SendSubscribe;
                }
                else if (msg.Type == 10)
                {
                    state = MqttMsgState.SendUnsubscribe;
                }

                MqttMsgContext mqttMsgContext2 = new MqttMsgContext();
                mqttMsgContext2.Message = msg;
                mqttMsgContext2.State = state;
                mqttMsgContext2.Flow = flow;
                mqttMsgContext2.Attempt = 0;
                MqttMsgContext mqttMsgContext3 = mqttMsgContext2;
                lock (inflightQueue)
                {
                    flag = inflightQueue.Count < settings.InflightQueueSize;
                    if (flag)
                    {
                        inflightQueue.Enqueue(mqttMsgContext3);
                        Trace.WriteLine(TraceLevel.Queuing, "enqueued {0}", msg);
                        if (msg.Type == 3)
                        {
                            if (mqttMsgContext3.Flow == MqttMsgFlow.ToPublish && (msg.QosLevel == 1 || msg.QosLevel == 2))
                            {
                                if (session != null)
                                {
                                    session.InflightMessages.Add(mqttMsgContext3.Key, mqttMsgContext3);
                                }
                            }
                            else if (mqttMsgContext3.Flow == MqttMsgFlow.ToAcknowledge && msg.QosLevel == 2 && session != null)
                            {
                                session.InflightMessages.Add(mqttMsgContext3.Key, mqttMsgContext3);
                            }
                        }
                    }
                }
            }

            inflightWaitHandle.Set();
            return flag;
        }

        private void EnqueueInternal(MqttMsgBase msg)
        {
            bool flag = true;
            if (msg.Type == 6)
            {
                lock (inflightQueue)
                {
                    MqttMsgContextFinder @object = new MqttMsgContextFinder(msg.MessageId, MqttMsgFlow.ToAcknowledge);
                    MqttMsgContext mqttMsgContext = (MqttMsgContext)inflightQueue.Get(@object.Find);
                    if (mqttMsgContext == null)
                    {
                        MqttMsgPubcomp mqttMsgPubcomp = new MqttMsgPubcomp();
                        mqttMsgPubcomp.MessageId = msg.MessageId;
                        Send(mqttMsgPubcomp);
                        flag = false;
                    }
                }
            }
            else if (msg.Type == 7)
            {
                lock (inflightQueue)
                {
                    MqttMsgContextFinder object2 = new MqttMsgContextFinder(msg.MessageId, MqttMsgFlow.ToPublish);
                    MqttMsgContext mqttMsgContext2 = (MqttMsgContext)inflightQueue.Get(object2.Find);
                    if (mqttMsgContext2 == null)
                    {
                        flag = false;
                    }
                }
            }
            else if (msg.Type == 5)
            {
                lock (inflightQueue)
                {
                    MqttMsgContextFinder object3 = new MqttMsgContextFinder(msg.MessageId, MqttMsgFlow.ToPublish);
                    MqttMsgContext mqttMsgContext3 = (MqttMsgContext)inflightQueue.Get(object3.Find);
                    if (mqttMsgContext3 == null)
                    {
                        flag = false;
                    }
                }
            }

            if (flag)
            {
                lock (internalQueue)
                {
                    internalQueue.Enqueue(msg);
                    Trace.WriteLine(TraceLevel.Queuing, "enqueued {0}", msg);
                    inflightWaitHandle.Set();
                }
            }
        }

        private void ReceiveThread()
        {
            int num = 0;
            byte[] array = new byte[1];
            while (isRunning)
            {
                try
                {
                    num = channel.Receive(array);
                    if (num > 0)
                    {
                        switch ((byte)((array[0] & 0xF0) >> 4))
                        {
                            case 1:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 2:
                                msgReceived = MqttMsgConnack.Parse(array[0], (byte)ProtocolVersion, channel);
                                Trace.WriteLine(TraceLevel.Frame, "RECV {0}", msgReceived);
                                syncEndReceiving.Set();
                                break;
                            case 12:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 13:
                                msgReceived = MqttMsgPingResp.Parse(array[0], (byte)ProtocolVersion, channel);
                                Trace.WriteLine(TraceLevel.Frame, "RECV {0}", msgReceived);
                                syncEndReceiving.Set();
                                break;
                            case 8:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 9:
                                {
                                    MqttMsgSuback mqttMsgSuback = MqttMsgSuback.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgSuback);
                                    EnqueueInternal(mqttMsgSuback);
                                    break;
                                }
                            case 3:
                                {
                                    MqttMsgPublish mqttMsgPublish = MqttMsgPublish.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgPublish);
                                    EnqueueInflight(mqttMsgPublish, MqttMsgFlow.ToAcknowledge);
                                    break;
                                }
                            case 4:
                                {
                                    MqttMsgPuback mqttMsgPuback = MqttMsgPuback.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgPuback);
                                    EnqueueInternal(mqttMsgPuback);
                                    break;
                                }
                            case 5:
                                {
                                    MqttMsgPubrec mqttMsgPubrec = MqttMsgPubrec.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgPubrec);
                                    EnqueueInternal(mqttMsgPubrec);
                                    break;
                                }
                            case 6:
                                {
                                    MqttMsgPubrel mqttMsgPubrel = MqttMsgPubrel.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgPubrel);
                                    EnqueueInternal(mqttMsgPubrel);
                                    break;
                                }
                            case 7:
                                {
                                    MqttMsgPubcomp mqttMsgPubcomp = MqttMsgPubcomp.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgPubcomp);
                                    EnqueueInternal(mqttMsgPubcomp);
                                    break;
                                }
                            case 10:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 11:
                                {
                                    MqttMsgUnsuback mqttMsgUnsuback = MqttMsgUnsuback.Parse(array[0], (byte)ProtocolVersion, channel);
                                    Trace.WriteLine(TraceLevel.Frame, "RECV {0}", mqttMsgUnsuback);
                                    EnqueueInternal(mqttMsgUnsuback);
                                    break;
                                }
                            case 14:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            default:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                        }

                        exReceiving = null;
                    }
                    else
                    {
                        OnConnectionClosing();
                    }
                }
                catch (Exception ex)
                {
                    Trace.WriteLine(TraceLevel.Error, "Exception occurred: {0}", ex.ToString());
                    exReceiving = new MqttCommunicationException(ex);
                    bool flag = false;
                    if (ex.GetType() == typeof(MqttClientException))
                    {
                        MqttClientException ex2 = ex as MqttClientException;
                        flag = ex2.ErrorCode == MqttClientErrorCode.InvalidFlagBits || ex2.ErrorCode == MqttClientErrorCode.InvalidProtocolName || ex2.ErrorCode == MqttClientErrorCode.InvalidConnectFlags;
                    }
                    else if (ex.GetType() == typeof(SocketException) || (ex.InnerException != null && ex.InnerException.GetType() == typeof(SocketException)))
                    {
                        flag = true;
                    }

                    if (flag)
                    {
                        OnConnectionClosing();
                    }
                }
            }
        }

        private void KeepAliveThread()
        {
            int num = 0;
            int millisecondsTimeout = keepAlivePeriod;
            keepAliveEventEnd = new AutoResetEvent(initialState: false);
            while (isRunning)
            {
                keepAliveEvent.WaitOne(millisecondsTimeout);
                if (isRunning)
                {
                    num = Environment.TickCount - lastCommTime;
                    if (num >= keepAlivePeriod)
                    {
                        Ping();
                        millisecondsTimeout = keepAlivePeriod;
                    }
                    else
                    {
                        millisecondsTimeout = keepAlivePeriod - num;
                    }
                }
            }

            keepAliveEventEnd.Set();
        }

        private void DispatchEventThread()
        {
            while (isRunning)
            {
                if (eventQueue.Count == 0 && !isConnectionClosing)
                {
                    receiveEventWaitHandle.WaitOne();
                }

                if (!isRunning)
                {
                    continue;
                }

                InternalEvent internalEvent = null;
                lock (eventQueue)
                {
                    if (eventQueue.Count > 0)
                    {
                        internalEvent = (InternalEvent)eventQueue.Dequeue();
                    }
                }

                if (internalEvent != null)
                {
                    MqttMsgBase message = ((MsgInternalEvent)internalEvent).Message;
                    if (message != null)
                    {
                        switch (message.Type)
                        {
                            case 1:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 8:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 9:
                                OnMqttMsgSubscribed((MqttMsgSuback)message);
                                break;
                            case 3:
                                if (internalEvent.GetType() == typeof(MsgPublishedInternalEvent))
                                {
                                    OnMqttMsgPublished(message.MessageId, isPublished: false);
                                }
                                else
                                {
                                    OnMqttMsgPublishReceived((MqttMsgPublish)message);
                                }

                                break;
                            case 4:
                                OnMqttMsgPublished(message.MessageId, isPublished: true);
                                break;
                            case 6:
                                OnMqttMsgPublishReceived((MqttMsgPublish)message);
                                break;
                            case 7:
                                OnMqttMsgPublished(message.MessageId, isPublished: true);
                                break;
                            case 10:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                            case 11:
                                OnMqttMsgUnsubscribed(message.MessageId);
                                break;
                            case 14:
                                throw new MqttClientException(MqttClientErrorCode.WrongBrokerMessage);
                        }
                    }
                }

                if (eventQueue.Count == 0 && isConnectionClosing)
                {
                    Close();
                    OnConnectionClosed();
                }
            }
        }

        private void ProcessInflightThread()
        {
            MqttMsgContext mqttMsgContext = null;
            MqttMsgBase mqttMsgBase = null;
            MqttMsgBase mqttMsgBase2 = null;
            InternalEvent internalEvent = null;
            bool flag = false;
            int num = -1;
            bool flag2 = false;
            try
            {
                while (isRunning)
                {
                    inflightWaitHandle.WaitOne(num);
                    if (!isRunning)
                    {
                        continue;
                    }

                    lock (inflightQueue)
                    {
                        flag2 = false;
                        flag = false;
                        mqttMsgBase2 = null;
                        num = int.MaxValue;
                        int num2 = inflightQueue.Count;
                        while (num2 > 0)
                        {
                            num2--;
                            flag = false;
                            mqttMsgBase2 = null;
                            if (!isRunning)
                            {
                                break;
                            }

                            mqttMsgContext = (MqttMsgContext)inflightQueue.Dequeue();
                            mqttMsgBase = mqttMsgContext.Message;
                            switch (mqttMsgContext.State)
                            {
                                case MqttMsgState.QueuedQos0:
                                    if (mqttMsgContext.Flow == MqttMsgFlow.ToPublish)
                                    {
                                        Send(mqttMsgBase);
                                    }
                                    else if (mqttMsgContext.Flow == MqttMsgFlow.ToAcknowledge)
                                    {
                                        internalEvent = new MsgInternalEvent(mqttMsgBase);
                                        OnInternalEvent(internalEvent);
                                    }

                                    Trace.WriteLine(TraceLevel.Queuing, "processed {0}", mqttMsgBase);
                                    break;
                                case MqttMsgState.QueuedQos1:
                                case MqttMsgState.SendSubscribe:
                                case MqttMsgState.SendUnsubscribe:
                                    if (mqttMsgContext.Flow == MqttMsgFlow.ToPublish)
                                    {
                                        mqttMsgContext.Timestamp = Environment.TickCount;
                                        mqttMsgContext.Attempt++;
                                        if (mqttMsgBase.Type == 3)
                                        {
                                            mqttMsgContext.State = MqttMsgState.WaitForPuback;
                                            if (mqttMsgContext.Attempt > 1)
                                            {
                                                mqttMsgBase.DupFlag = true;
                                            }
                                        }
                                        else if (mqttMsgBase.Type == 8)
                                        {
                                            mqttMsgContext.State = MqttMsgState.WaitForSuback;
                                        }
                                        else if (mqttMsgBase.Type == 10)
                                        {
                                            mqttMsgContext.State = MqttMsgState.WaitForUnsuback;
                                        }

                                        Send(mqttMsgBase);
                                        num = ((settings.DelayOnRetry < num) ? settings.DelayOnRetry : num);
                                        inflightQueue.Enqueue(mqttMsgContext);
                                    }
                                    else if (mqttMsgContext.Flow == MqttMsgFlow.ToAcknowledge)
                                    {
                                        MqttMsgPuback mqttMsgPuback = new MqttMsgPuback();
                                        mqttMsgPuback.MessageId = mqttMsgBase.MessageId;
                                        Send(mqttMsgPuback);
                                        internalEvent = new MsgInternalEvent(mqttMsgBase);
                                        OnInternalEvent(internalEvent);
                                        Trace.WriteLine(TraceLevel.Queuing, "processed {0}", mqttMsgBase);
                                    }

                                    break;
                                case MqttMsgState.QueuedQos2:
                                    if (mqttMsgContext.Flow == MqttMsgFlow.ToPublish)
                                    {
                                        mqttMsgContext.Timestamp = Environment.TickCount;
                                        mqttMsgContext.Attempt++;
                                        mqttMsgContext.State = MqttMsgState.WaitForPubrec;
                                        if (mqttMsgContext.Attempt > 1)
                                        {
                                            mqttMsgBase.DupFlag = true;
                                        }

                                        Send(mqttMsgBase);
                                        num = ((settings.DelayOnRetry < num) ? settings.DelayOnRetry : num);
                                        inflightQueue.Enqueue(mqttMsgContext);
                                    }
                                    else if (mqttMsgContext.Flow == MqttMsgFlow.ToAcknowledge)
                                    {
                                        MqttMsgPubrec mqttMsgPubrec = new MqttMsgPubrec();
                                        mqttMsgPubrec.MessageId = mqttMsgBase.MessageId;
                                        mqttMsgContext.State = MqttMsgState.WaitForPubrel;
                                        Send(mqttMsgPubrec);
                                        inflightQueue.Enqueue(mqttMsgContext);
                                    }

                                    break;
                                case MqttMsgState.WaitForPuback:
                                case MqttMsgState.WaitForSuback:
                                case MqttMsgState.WaitForUnsuback:
                                    {
                                        if (mqttMsgContext.Flow != 0)
                                        {
                                            break;
                                        }

                                        flag = false;
                                        lock (internalQueue)
                                        {
                                            if (internalQueue.Count > 0)
                                            {
                                                mqttMsgBase2 = (MqttMsgBase)internalQueue.Peek();
                                            }
                                        }

                                        if (mqttMsgBase2 != null && ((mqttMsgBase2.Type == 4 && mqttMsgBase.Type == 3 && mqttMsgBase2.MessageId == mqttMsgBase.MessageId) || (mqttMsgBase2.Type == 9 && mqttMsgBase.Type == 8 && mqttMsgBase2.MessageId == mqttMsgBase.MessageId) || (mqttMsgBase2.Type == 11 && mqttMsgBase.Type == 10 && mqttMsgBase2.MessageId == mqttMsgBase.MessageId)))
                                        {
                                            lock (internalQueue)
                                            {
                                                internalQueue.Dequeue();
                                                flag = true;
                                                flag2 = true;
                                                Trace.WriteLine(TraceLevel.Queuing, "dequeued {0}", mqttMsgBase2);
                                            }

                                            internalEvent = ((mqttMsgBase2.Type != 4) ? new MsgInternalEvent(mqttMsgBase2) : new MsgPublishedInternalEvent(mqttMsgBase2, isPublished: true));
                                            OnInternalEvent(internalEvent);
                                            if (mqttMsgBase.Type == 3 && session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                            {
                                                session.InflightMessages.Remove(mqttMsgContext.Key);
                                            }

                                            Trace.WriteLine(TraceLevel.Queuing, "processed {0}", mqttMsgBase);
                                        }

                                        if (flag)
                                        {
                                            break;
                                        }

                                        int num3 = Environment.TickCount - mqttMsgContext.Timestamp;
                                        if (num3 >= settings.DelayOnRetry)
                                        {
                                            if (mqttMsgContext.Attempt < settings.AttemptsOnRetry)
                                            {
                                                mqttMsgContext.State = MqttMsgState.QueuedQos1;
                                                inflightQueue.Enqueue(mqttMsgContext);
                                                num = 0;
                                            }
                                            else if (mqttMsgBase.Type == 3)
                                            {
                                                if (session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                                {
                                                    session.InflightMessages.Remove(mqttMsgContext.Key);
                                                }

                                                internalEvent = new MsgPublishedInternalEvent(mqttMsgBase, isPublished: false);
                                                OnInternalEvent(internalEvent);
                                            }
                                        }
                                        else
                                        {
                                            inflightQueue.Enqueue(mqttMsgContext);
                                            int num6 = settings.DelayOnRetry - num3;
                                            num = ((num6 < num) ? num6 : num);
                                        }

                                        break;
                                    }
                                case MqttMsgState.WaitForPubrec:
                                    {
                                        if (mqttMsgContext.Flow != 0)
                                        {
                                            break;
                                        }

                                        flag = false;
                                        lock (internalQueue)
                                        {
                                            if (internalQueue.Count > 0)
                                            {
                                                mqttMsgBase2 = (MqttMsgBase)internalQueue.Peek();
                                            }
                                        }

                                        if (mqttMsgBase2 != null && mqttMsgBase2.Type == 5 && mqttMsgBase2.MessageId == mqttMsgBase.MessageId)
                                        {
                                            lock (internalQueue)
                                            {
                                                internalQueue.Dequeue();
                                                flag = true;
                                                flag2 = true;
                                                Trace.WriteLine(TraceLevel.Queuing, "dequeued {0}", mqttMsgBase2);
                                            }

                                            MqttMsgPubrel mqttMsgPubrel2 = new MqttMsgPubrel();
                                            mqttMsgPubrel2.MessageId = mqttMsgBase.MessageId;
                                            mqttMsgContext.State = MqttMsgState.WaitForPubcomp;
                                            mqttMsgContext.Timestamp = Environment.TickCount;
                                            mqttMsgContext.Attempt = 1;
                                            Send(mqttMsgPubrel2);
                                            num = ((settings.DelayOnRetry < num) ? settings.DelayOnRetry : num);
                                            inflightQueue.Enqueue(mqttMsgContext);
                                        }

                                        if (flag)
                                        {
                                            break;
                                        }

                                        int num3 = Environment.TickCount - mqttMsgContext.Timestamp;
                                        if (num3 >= settings.DelayOnRetry)
                                        {
                                            if (mqttMsgContext.Attempt < settings.AttemptsOnRetry)
                                            {
                                                mqttMsgContext.State = MqttMsgState.QueuedQos2;
                                                inflightQueue.Enqueue(mqttMsgContext);
                                                num = 0;
                                                break;
                                            }

                                            if (session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                            {
                                                session.InflightMessages.Remove(mqttMsgContext.Key);
                                            }

                                            internalEvent = new MsgPublishedInternalEvent(mqttMsgBase, isPublished: false);
                                            OnInternalEvent(internalEvent);
                                        }
                                        else
                                        {
                                            inflightQueue.Enqueue(mqttMsgContext);
                                            int num5 = settings.DelayOnRetry - num3;
                                            num = ((num5 < num) ? num5 : num);
                                        }

                                        break;
                                    }
                                case MqttMsgState.WaitForPubrel:
                                    if (mqttMsgContext.Flow != MqttMsgFlow.ToAcknowledge)
                                    {
                                        break;
                                    }

                                    lock (internalQueue)
                                    {
                                        if (internalQueue.Count > 0)
                                        {
                                            mqttMsgBase2 = (MqttMsgBase)internalQueue.Peek();
                                        }
                                    }

                                    if (mqttMsgBase2 != null && mqttMsgBase2.Type == 6)
                                    {
                                        if (mqttMsgBase2.MessageId == mqttMsgBase.MessageId)
                                        {
                                            lock (internalQueue)
                                            {
                                                internalQueue.Dequeue();
                                                flag2 = true;
                                                Trace.WriteLine(TraceLevel.Queuing, "dequeued {0}", mqttMsgBase2);
                                            }

                                            MqttMsgPubcomp mqttMsgPubcomp = new MqttMsgPubcomp();
                                            mqttMsgPubcomp.MessageId = mqttMsgBase.MessageId;
                                            Send(mqttMsgPubcomp);
                                            internalEvent = new MsgInternalEvent(mqttMsgBase);
                                            OnInternalEvent(internalEvent);
                                            if (mqttMsgBase.Type == 3 && session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                            {
                                                session.InflightMessages.Remove(mqttMsgContext.Key);
                                            }

                                            Trace.WriteLine(TraceLevel.Queuing, "processed {0}", mqttMsgBase);
                                        }
                                        else
                                        {
                                            inflightQueue.Enqueue(mqttMsgContext);
                                        }
                                    }
                                    else
                                    {
                                        inflightQueue.Enqueue(mqttMsgContext);
                                    }

                                    break;
                                case MqttMsgState.WaitForPubcomp:
                                    {
                                        if (mqttMsgContext.Flow != 0)
                                        {
                                            break;
                                        }

                                        flag = false;
                                        lock (internalQueue)
                                        {
                                            if (internalQueue.Count > 0)
                                            {
                                                mqttMsgBase2 = (MqttMsgBase)internalQueue.Peek();
                                            }
                                        }

                                        if (mqttMsgBase2 != null && mqttMsgBase2.Type == 7)
                                        {
                                            if (mqttMsgBase2.MessageId == mqttMsgBase.MessageId)
                                            {
                                                lock (internalQueue)
                                                {
                                                    internalQueue.Dequeue();
                                                    flag = true;
                                                    flag2 = true;
                                                    Trace.WriteLine(TraceLevel.Queuing, "dequeued {0}", mqttMsgBase2);
                                                }

                                                internalEvent = new MsgPublishedInternalEvent(mqttMsgBase2, isPublished: true);
                                                OnInternalEvent(internalEvent);
                                                if (mqttMsgBase.Type == 3 && session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                                {
                                                    session.InflightMessages.Remove(mqttMsgContext.Key);
                                                }

                                                Trace.WriteLine(TraceLevel.Queuing, "processed {0}", mqttMsgBase);
                                            }
                                        }
                                        else if (mqttMsgBase2 != null && mqttMsgBase2.Type == 5 && mqttMsgBase2.MessageId == mqttMsgBase.MessageId)
                                        {
                                            lock (internalQueue)
                                            {
                                                internalQueue.Dequeue();
                                                flag = true;
                                                flag2 = true;
                                                Trace.WriteLine(TraceLevel.Queuing, "dequeued {0}", mqttMsgBase2);
                                                inflightQueue.Enqueue(mqttMsgContext);
                                            }
                                        }

                                        if (flag)
                                        {
                                            break;
                                        }

                                        int num3 = Environment.TickCount - mqttMsgContext.Timestamp;
                                        if (num3 >= settings.DelayOnRetry)
                                        {
                                            if (mqttMsgContext.Attempt < settings.AttemptsOnRetry)
                                            {
                                                mqttMsgContext.State = MqttMsgState.SendPubrel;
                                                inflightQueue.Enqueue(mqttMsgContext);
                                                num = 0;
                                                break;
                                            }

                                            if (session != null && session.InflightMessages.ContainsKey(mqttMsgContext.Key))
                                            {
                                                session.InflightMessages.Remove(mqttMsgContext.Key);
                                            }

                                            internalEvent = new MsgPublishedInternalEvent(mqttMsgBase, isPublished: false);
                                            OnInternalEvent(internalEvent);
                                        }
                                        else
                                        {
                                            inflightQueue.Enqueue(mqttMsgContext);
                                            int num4 = settings.DelayOnRetry - num3;
                                            num = ((num4 < num) ? num4 : num);
                                        }

                                        break;
                                    }
                                case MqttMsgState.SendPubrel:
                                    if (mqttMsgContext.Flow == MqttMsgFlow.ToPublish)
                                    {
                                        MqttMsgPubrel mqttMsgPubrel = new MqttMsgPubrel();
                                        mqttMsgPubrel.MessageId = mqttMsgBase.MessageId;
                                        mqttMsgContext.State = MqttMsgState.WaitForPubcomp;
                                        mqttMsgContext.Timestamp = Environment.TickCount;
                                        mqttMsgContext.Attempt++;
                                        if (ProtocolVersion == MqttProtocolVersion.Version_3_1 && mqttMsgContext.Attempt > 1)
                                        {
                                            mqttMsgPubrel.DupFlag = true;
                                        }

                                        Send(mqttMsgPubrel);
                                        num = ((settings.DelayOnRetry < num) ? settings.DelayOnRetry : num);
                                        inflightQueue.Enqueue(mqttMsgContext);
                                    }

                                    break;
                            }
                        }

                        if (num == int.MaxValue)
                        {
                            num = -1;
                        }

                        if (mqttMsgBase2 != null && !flag2)
                        {
                            internalQueue.Dequeue();
                            Trace.WriteLine(TraceLevel.Queuing, "dequeued {0} orphan", mqttMsgBase2);
                        }
                    }
                }
            }
            catch (MqttCommunicationException ex)
            {
                if (mqttMsgContext != null)
                {
                    inflightQueue.Enqueue(mqttMsgContext);
                }

                Trace.WriteLine(TraceLevel.Error, "Exception occurred: {0}", ex.ToString());
                OnConnectionClosing();
            }
        }

        private void RestoreSession()
        {
            if (!CleanSession)
            {
                if (session != null)
                {
                    lock (inflightQueue)
                    {
                        foreach (MqttMsgContext value in session.InflightMessages.Values)
                        {
                            inflightQueue.Enqueue(value);
                            if (value.Message.Type != 3 || value.Flow != 0)
                            {
                                continue;
                            }

                            if (value.Message.QosLevel == 1 && value.State == MqttMsgState.WaitForPuback)
                            {
                                value.State = MqttMsgState.QueuedQos1;
                            }
                            else if (value.Message.QosLevel == 2)
                            {
                                if (value.State == MqttMsgState.WaitForPubrec)
                                {
                                    value.State = MqttMsgState.QueuedQos2;
                                }
                                else if (value.State == MqttMsgState.WaitForPubcomp)
                                {
                                    value.State = MqttMsgState.SendPubrel;
                                }
                            }
                        }
                    }

                    inflightWaitHandle.Set();
                }
                else
                {
                    session = new MqttClientSession(ClientId);
                }
            }
            else if (session != null)
            {
                session.Clear();
            }
        }

        private ushort GetMessageId()
        {
            messageIdCounter = (ushort)(((int)messageIdCounter % 65535 == 0) ? 1 : ((ushort)(messageIdCounter + 1)));
            return messageIdCounter;
        }
    }
}
#if false // Decompilation log
'13' items in cache
------------------
Resolve: 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
Found single assembly: 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
Load from: 'C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2\mscorlib.dll'
------------------
Resolve: 'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
Found single assembly: 'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
Load from: 'C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2\System.dll'
#endif
